// Copyright (c) 2015 Hewlett-Packard Development Company, L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::path::PathBuf;
use std::fs;
use std::process::Command;

use ::config_drive::ConfigDrive;
use ::sys::SysInterfaces;
use self::interface_type::InterfaceType;
use self::interface_type::InterfaceType::{Static, Dhcp};
use self::Platform::{RedHat, Debian};

mod interface_type;

#[derive(Debug)]
pub struct LiveNetworks {
    interfaces: Vec<InterfaceType>,
    platform: Platform,
}

impl LiveNetworks {

    pub fn new(interfaces: &SysInterfaces, config_drive: Option<ConfigDrive>) -> LiveNetworks {

      let mut live_ifaces = Vec::new();
      for iface in interfaces.interfaces.iter() {
          match config_drive {
              Some(ref drive) =>
                  match drive.interface_map.get(&iface.address) {
                      Some(network) => {
                          let mut new_net = network.clone();
                          new_net.id = iface.iface.clone();
                          live_ifaces.push(Static(new_net));
                      },
                      None => live_ifaces.push(Dhcp(iface.iface.clone())),
                  },
              None => live_ifaces.push(Dhcp(iface.iface.clone())),
          }
      }
      live_ifaces.sort();

      let platform;
      match fs::metadata("/etc/network") {
          Ok(metadata) => {
              if metadata.is_dir() {
                  platform = Debian;
              } else {
                  platform = RedHat;
              }
          },
          Err(_) => {
              platform = RedHat;
          },
      };
      LiveNetworks {
          interfaces: live_ifaces,
          platform: platform,
      }
    }

    pub fn get_output(&self) -> FileList {
        println!("{:?}", self.platform);
        match self.platform {
            RedHat => {
                let w = RedHatWriter;
                return get_output_files(&w as &Writer, &self.interfaces);
            }
            Debian => {
                let w = DebianWriter;
                return get_output_files(&w as &Writer, &self.interfaces);
            }
        };
    }
}

fn get_output_files(writer: &Writer, interfaces: &Vec<InterfaceType>) -> FileList {
    let mut file_list = Vec::<FileToWrite>::new();
    for interface in interfaces.iter() {
        let iface = match(interface) {
            &Static(ref network) => network.id.clone(),
            &Dhcp(ref iface) => iface.clone(),
        };
        if ! writer.config_exists(&iface) {
            println!("Don't have: {}", iface);
            file_list.push(writer.generate_config(&iface, &interface));
        } else {
            println!("Already have: {}", iface);
        }
    }
    FileList { files: file_list }
}

#[derive(Debug)]
pub struct FileList {
   files: Vec<FileToWrite>,
}

impl FileList {
   pub fn write(&self) {
      println!("{:?}", self.files);
   }
}


#[derive(Debug)]
struct FileToWrite {
    path: PathBuf,
    content: String,
}

#[derive(Debug)]
enum Platform {
  RedHat,
  Debian,
}

struct RedHatWriter;
struct DebianWriter;

trait Writer {
    fn config_exists(&self, iface: &String) -> bool;
    fn generate_config(&self, iface: &String, interface: &InterfaceType) -> FileToWrite;
}

impl Writer for RedHatWriter {
    fn config_exists(&self, iface: &String) -> bool {
      // TODO plumb root positioning in here
      let mut path_str = String::from("/etc/sysconfig/network-scripts/ifcfg-");
      path_str.push_str(iface);
      match fs::metadata(path_str) {
          Ok(metadata) => return metadata.is_file(),
          Err(_) => return false,
      }
    }

    fn generate_config(&self, iface: &String, interface: &InterfaceType) -> FileToWrite {
        return FileToWrite { path: PathBuf::from(""), content: String::from("") };
    }
}

impl Writer for DebianWriter {
    fn config_exists(&self, iface: &String) -> bool {
      match Command::new("ifquery").arg(iface).status() {
        Err(why) => { debug!("ifquery error: {}", why); return false ; }
        Ok(status) => return status.success(),
      }
    }
    fn generate_config(&self, iface: &String, interface: &InterfaceType) -> FileToWrite {
        let filename = PathBuf::from("/etc/network/interfaces.d").join(iface);
        let content;
        match interface {
            &Dhcp(ref network) => { content = format!("# {bullet}
aut0 {iface}
iface {iface} inet dhcp", bullet="Generated by gleam", iface=iface) },
            &Static(ref network) => {
                let link_type;
                if network.network_type == "ipv6" {
                    link_type = "inet6";
                } else {
                    link_type = "inet";
                }
                content = format!("# {bullet}
aut0 {iface}
iface {iface} {link_type} static
    address {ip_address}
    netmask {netmask}", bullet="Generated by gleam", iface=iface, link_type=link_type, ip_address=network.ip_address, netmask=network.netmask);
            }
        };

        return FileToWrite {
            path: filename,
            content: content,
        };
    }
}
